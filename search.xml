<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue组件间的通信方式]]></title>
    <url>%2F09%2F16%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[PS：加班使我麻木，终于想起来要更一下博客了。Vue组件间的通信方式是老生常谈了，所以必不可免地简单地归纳一下。主要分为八个方向：Props传递数据，$emit，$parent+$children，$attrs+$listeners，Provide+Inject，Ref，EventBus，Vuex 1. Props传递数据（父传子）父组件调用子组件123456789101112131415161718&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123;msg&#125;&#125; &lt;Son :msg="msg"&gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from "./Son"export default &#123; components: &#123; Son &#125;, data() &#123; return &#123; msg: 'From Father' &#125;; &#125;&#125;;&lt;/script&gt; 子组件获取数据123456789101112131415&lt;template&gt; &lt;div&gt;来自父组件的消息：&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Son', props: &#123; msg: &#123; type: String, required: true &#125; &#125;&#125;&lt;/script&gt; 2. $emit传递数据子组件触发父组件方法,通过回调的方式将修改的内容传递给父组件1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123; price &#125;&#125; &lt;Son :price="price" @input="change"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from './Son'export default &#123; components: &#123; Son &#125;, data() &#123; return &#123; price: 100 &#125; &#125;, methods: &#123; change(price) &#123; this.price = price &#125; &#125;&#125;&lt;/script&gt; 子组件触发绑定自己身上的方法1234567891011121314151617&lt;template&gt; &lt;div&gt; 子组件: &#123;&#123; price &#125;&#125; &lt;button @click="$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; price: &#123; type: Number, required: true &#125; &#125;&#125;&lt;/script&gt; .sync123&lt;Son :price.sync="price"&gt;&lt;/Son&gt;&lt;!-- 触发的事件名 update:(绑定.sync属性的名字) --&gt;&lt;button @click="$emit('update:price',200)"&gt;更改&lt;/button&gt; v-model123456789101112131415161718192021&lt;!-- 父组件调用子组件 --&gt;&lt;Son v-model="price"&gt;&lt;/Son&gt;&lt;!-- 子组件触发更改 --&gt;&lt;template&gt; &lt;div&gt; 子组件: &#123;&#123; value &#125;&#125; // 触发的事件只能是input &lt;button @click="$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; // 接收到的属性名只能叫value type: Number, required: true &#125; &#125;&#125;&lt;/script&gt; 3. $parent、$children父传子，子传孙。123456789101112131415161718192021&lt;!-- 子组件调用孙子组件 --&gt;&lt;Grandson :value="value"&gt;&lt;/Grandson&gt;&lt;!-- 孙子组件 --&gt;&lt;template&gt; &lt;div&gt; 孙子:&#123;&#123; value &#125;&#125; &lt;!-- 调用父组件的input事件 --&gt; &lt;button @click="$parent.$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; type: Number, required: true &#125; &#125;&#125;&lt;/script&gt; 如果层级很深那么就会出现$parent.$parent…..可以封装一个$dispatch方法向上进行派发 $dispatch1234567Vue.prototype.$dispatch = function $dispatch(eventName, data) &#123; let parent = this.$parent while (parent) &#123; parent.$emit(eventName, data) parent = parent.$parent &#125;&#125; 同理，可以向上派发 $broadcast1234567891011Vue.prototype.$broadcast = function $broadcast(eventName, data) &#123; const broadcast = function() &#123; this.$children.forEach((child) =&gt; &#123; child.$emit(eventName, data) if (child.$children) &#123; $broadcast.call(child, eventName, data) &#125; &#125;) &#125; broadcast.call(this, eventName, data)&#125; 4. $attrs、$listeners 批量向下传递属性 $attrs12345678910111213&lt;!-- 父组件调用子组件 --&gt;&lt;Son name="测试" age="10"&gt;&lt;/Son&gt;&lt;!-- 可以在son组件中使用$attrs属性,可以将属性继续向下传递 --&gt;&lt;div&gt; 儿子: &#123;&#123;$attrs.name&#125;&#125; &lt;Grandson v-bind="$attrs"&gt;&lt;/Grandson&gt;&lt;/div&gt;&lt;!-- 孙子组件 --&gt;&lt;template&gt; &lt;div&gt;孙子:&#123;&#123; $attrs &#125;&#125;&lt;/div&gt;&lt;/template&gt; 批量向上传递属性 $listeners12345678&lt;!-- 父组件调用子组件 --&gt;&lt;Son name="测试" age="10" @click="()=&gt;&#123;this.price = 500&#125;"&gt;&lt;/Son&gt;&lt;!-- 子组件：可以在son组件中使用listeners属性,可以将方法继续向下传递 --&gt;&lt;Grandson v-bind="$attrs" v-on="$listeners"&gt;&lt;/Grandson&gt;&lt;!-- 孙子组件 --&gt;&lt;button @click="$listeners.click()"&gt;更改&lt;/button&gt; 5. Provide、 Inject Provie: 在父级中注入数据 123provide() &#123; return &#123; parentMsg: "父亲" &#125;&#125; Inject: 在任意子组件中可以注入父级数据 12// 会将数据挂载在当前实例上inject: ["parentMsg"] 6. Ref获取组件实例Ref我常用于调用子组件的属性和方法，简洁明了。1234567891011&lt;!-- 父级组件调用子级组件 --&gt;&lt;Grandson v-bind="$attrs" v-on="$listeners" ref="grand"&gt;&lt;/Grandson&gt;&lt;script&gt;export default &#123; mounted() &#123; // 获取组件定义的属性 console.log(this.$refs.grand.name) &#125;&#125;&lt;/script&gt; 7. EventBus其实就是利用一个Vue实例传递数据，实现跨组件通知（简单的项目可以使用此方式）1Vue.prototype.$bus = new Vue() Son组件和Grandson相互通信12345mounted() &#123; this.$bus.$on("my", data =&gt; &#123; console.log(data); &#125;)&#125; 12345mounted() &#123; this.$nextTick(() =&gt; &#123; this.$bus.$emit("my", "我是Grandson"); &#125;)&#125; 8. Vuex状态管理数据通信交互较多的项目还是用Vuex统一管理吧，具体使用参考Vuex官方文档，在这就放个图。 最后，总结一波： 父传子： Props, $broadcast, $attrs, $listeners, Provide+Inject 子传父： $emit, $dispatch 父子双向： .sync, v-model 兄弟互传：EventBus, Vuex （PS：也可以都dispatch到最上层父级再派发，但是不建议）]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户体验那些事 About UE]]></title>
    <url>%2F11%2F23%2F%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[PS：频繁地换电脑一度中断了我写博客的心情，嗯，感慨一下，终于。关于用户体验其实有太多的内容可以研究，鉴于之前在工作小组内做过分享，浅显地总结归纳为三个方面：布局优化，内容优化，配色优化。在这里做个简单地总结。 Such conent to study about UE. as the previous sharing in my work team, can be summarized into 3 aspects: layout optimization, content optimization，color matching optimization. Just make a brief summary here. 布局优化 Layout Optimization布局优化旨在页面组件结构的优化，让页面更简洁美观并且舒适。大致可以归纳成三点:专注主题，保持简洁，适当的突出与柔化Layout optimization is designed to optimize the structure of the page components, making the page more concise and comfortable. It can be roughly summarized into three points: Keep Focus，Keep Concise，Appropriate highlighting and softening *Try Merging Similar Functions instead of fragmenting the UIExample: Try A One Column Layout instead of multi-columnsExample: Try Recommending instead of showing equal choicesExample: Try Friendly Comparisons instead of confusionExample: Try Fewer Borders instead of wasting attention Try Softer Prompts instead of modal windows Try line of sight instead of jumping 内容优化 Contetnt Optimization内容优化旨在用户交互的内容及流程优化。大致可以归纳成四点：易学性，高效性，满足性，错误处理Contetnt optimization is aimed at the process and content optimization of user interaction.It can be roughly summarized into three points: Learnability，Efficiency，Satisfaction，Error Handle Try Social Proof instead of talking about yourselfExample: Try Fewer Form Fields instead of asking for too manyExample: Try Undos instead of prompting for confirmationExample: Try Set Collections instead of independent itemsExample: Try Telling Who It’s For instead of targeting everyone Try Exposing Options instead of hiding them Try Keeping Focus instead of drowning with links Try Selling Benefits instead of features Try Opt-Out instead of opt-in Try smart defaults instead of asking to do extra work Try Recognition instead of recallExample: Try Inline Validation instead of delaying errorsExample: Try to show error more friendlyExample: 配色优化 Color Matching Optimization配色优化旨在页面整体视觉效果的优化。大致可以归纳为3点：舒适，和谐，可区分Color optimization is optimized for the overall visual effect of the page. It can be roughly summarized into three points: comfortable， harmonious, diacritical 根据网页主题风格配色 Color matching according to the theme of the webpage 黄色：乐观、年轻，常被使用在获取window shopper的注意力 红色：充满活力、心跳加速、创造急迫性，常出现在清仓大拍卖 蓝色：建立信任感和安全感，常出现在银行和企业 绿色：跟健康有关，对眼睛来说最舒服的颜色，通常会使用在实体店家，可传递放松的感觉 橘色：积极、创造行动呼吁，以带动订阅、购买或销售 粉红色：浪漫和女性主义，通常会女性的和年轻女性的产品市场出现 黑色：强而有力，通常出现在奢华的商品上 紫色：放松和冷静，常被用在常美妆和抗老化的产品 同一版面勿使用超过3种纯色，宁缺毋滥 Do not use more than 3 solid colors for the same layout 超链接的样式与状态的色彩搭配 The style of hyperlink status(Status: normal, hover, focus, visited) -&gt; -&gt; -&gt; 浅色背景搭配深色字体较易阅读 A light background with a dark font is easier to read 所提及的内容经本人筛选，适用于较为严肃的商业网站。 参考： goodui]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客缘起 Why Blog]]></title>
    <url>%2F04%2F14%2Fhello-world%20%2F</url>
    <content type="text"><![CDATA[自博客兴起之时就想着要写个自己的博客。看着人家名人发发博文，分享生活感悟，就想把自己写的那些诗文都发到博客上，也算是个念想、无奈自己是个极懒之人，也没什么耐心，估摸着自己开个博客也无心经营，遂放弃。直到大学毕业，自己入了程序猿这个坑，才把这个念想拾起。但苦于自己没什么水平，迟迟没有动手，直到现在。为什么现在想写博客了呢？写给自己。随着自己在程序猿这条路越走越远，遇到的一些问题和解决方案，总得记录下来，即使有些问题我已经心知肚明，但是也还是想把这些积累下来，帮助自己，说不定也能帮助到别人。同时，希望自己能写个中英文的博客，就当练练英文吧。至于，能不能坚持下来呢，随心吧。 Since the rise of the blog, I wanna build a blog of mine. Why? Cause I found that celebrities write their blog to share life and sentiment, which is funny. So that I wanna post my poems and articles on the blog. But what a pretty lazy and no patience people of me, that I thought I cannot keep manamge the blog as time gone. So, abandon. Until graduated, pick up this mind when I jump down to the developer career. Cause I known I have nothing deserve to write on the blog, haven’t do it yet. But why blog now? For myself. As my job of developer, so many problems and confuse worth to mark it, even some of them had keep in my mind. I hope these can help me, maybe some one else. At the same time, I hope that I can write a blog with Chinese and English for my English practice. As for, whether it can hold on just depends on my mood. 1Console.log("Welcome to Avril's Blog.");]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
