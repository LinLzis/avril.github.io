<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【serverless + hexo】极速搭建个人博客三步曲]]></title>
    <url>%2F08%2F23%2Fsls-build-blog%2F</url>
    <content type="text"><![CDATA[(PS:换了个城市工作，开始入坑serverless，一直想写篇入门级的关于serverless的文章，无奈被各种琐事拖延，终于又…)作为一个经历过需要繁复步骤才能搭建博客的程序员，如今不会写代码、没有域名、没有服务器也能够免费建站简直不要太幸福，入了github+hexo的坑以后，通过工作了解serverless framework后结合hexo更是便捷。三分钟极速建博客，只需三步：安装与初始化 —&gt; 配置yml文件 —&gt; 部署 工具介绍 Serverless Framework： Serverless Framework 是业界非常受欢迎的无服务器应用框架，开发者无需关心底层资源即可部署完整可用的 Serverless 应用架构。 Hexo： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装与初始化首先请确保你的操作系统包含以下环境： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) Git 如未安装以上程序，请参考Hexo安装说明 安装Serverless Framework全局安装serverless framework，若已安装强烈建议升级到最新版本。（PS:最近升级优化了） 1$ npm install serverless -g 安装Hexo1$ npm install -g hexo-cli 初始化项目123$ hexo init sls-blog # 生成hexo项目目录:sls-blog$ cd sls-blo$ npm install 初始化完成后，sls-blog文件夹的目录如下： 1234567.├── _config.yml├── package.json├── scaffolds├── source| └── _posts└── themes 生成本地博客页面1$ hexo g # 即hexo generate的缩写命令 可以通过 hexo g 命令生成静态页面，如果希望在本地查看效果，也可以运行hexo s（即hexo server的缩写命令），通过浏览器访问 http://localhost:4000 查看页面效果。 配置yml文件在项目的根目录下创建serverless.yml文件，此处文件名不可自定义。1$ touch serverless.yml 配置serverless相关信息，将以下内容写入上述的yml文件中。 注意：此处是基于tencent-website组件进行配置部署，目前该组件已升级到v2版本，yml配置文件均已更新到最新格式。截止本文发表，相关的文章的yml配置均基于v1版本进行配置。 12345678910111213# serverless.ymlcomponent: websitename: blogdemoapp: my-sls-bloginputs: src: src: ./public index: index.html region: ap-guangzhou bucketName: my-bucket-hexo protocol: https 配置完成后，文件目录结构如下：12345678.├── serverless.yml├── _config.yml├── package.json├── scaffolds├── source| └── _posts└── themes 部署通过 sls deploy 命令进行部署，并可以添加--debug参数查看部署过程中的信息 如您的账号未登陆或注册腾讯云，您可以直接通过微信扫描命令行中的二维码进行授权登陆和注册。 123456789101112131415$ sls deploy --debugInitializing...[此处为微信扫描二维码]Please scan QR code login from wechat. Wait login...Login successful for TencentCloud. Action: "deploy" - Stage: "dev" - App: "my-sls-blog" - Instance: "blogdemo"the code will be uploaded to https://sp-ins-prod-1300963013.cos.ap-guangzhou.myqcloud.com/f9ef45d1-80f8-4af2-9708-98b88e89xxx.zip?q-sign-algorithm=sha1&amp;q-ak=AKID1qcBe1cVaOwSmtn67y7pJJIAVj4jfxxx&amp;q-sign-time=1598172093;1598172693&amp;q-key-time=1598172093;1598172693&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=31c94f36d04a6b2f660014362604bb0e646f2xxxDeploying...region: ap-guangzhouwebsite: https://my-bucket-hexo-1302319935.cos-website.ap-guangzhou.myqcloud.comFull details: https://serverless.cloud.tencent.com/instances/my-sls-blog%3Adev%3Ablogdemo20s › blogdemo › Success 访问命令行输出的website url，即可查看属于自己的 Serverless Hexo 站点。 此处我这个项目部署拿到的url为：https://my-bucket-hexo-1302319935.cos-website.ap-guangzhou.myqcloud.com 这样就大功告成啦！[手动撒花] 总结与后话本文教程已经达到快速建站的目的，今后如何写文章或修改内容还需学习Hexo的使用（真的很简单），修改完毕并运行hexo g命令后，重新部署只需照旧运行sls deploy即可。这一切的便捷多亏了腾讯云的serverless服务，能够帮我们快速地部署个人博客。也多亏了Hexo这个强大的静态博客生成器，才能不费劲地拥有美观的博客页面。Hexo还提供了丰富的插件与个性化功能，打造具有个人特色的博客网站。Serverless能做的还很多，一句话说就是一切都可以上云，有兴趣了解的附上传送门： Serverless Github Serverless中文官网 Hexo官方文档 后话: 虽然本文教你如何没有域名也能拥有博客，但是对于需要有个好(zhuang)看(bi)的域名的大佬们来说还不够。推荐通过腾讯云购买域名（货比三家是真的便宜，只需要几块钱人民币）一键申请SSL证书、备案，然后一波配置就可以啦。大概步骤和传送门如下： 购买自己喜欢的域名[腾讯云域名注册] 进行域名备案，大概需要两三个星期[域名备案教程] [云服务器购买] 申请SSL证书，证书颁发后点击域名最后的‘更多’中的部署到CDN将域名部署到CDN[申请证书] [配置CDN证书] 将CDN配置到博客对应的存储桶中，即可以该域名访问[存储桶管理]即在腾讯云控制台的对象存储-&gt;存储桶列表中找到上面yml配置的bucketName（比如上面我的配置是：my-bucket-hexo）,点击该存储桶进入详情页面，点击左侧菜单中的域名管理进行CDN配置关联。 将对应的域名配置同步到博客项目的yml文件的hosts参数中yml配置 最后，真的不想自己动(zhuang)手(bi)的话还是在知乎之类的平台做分享吧。最后的最后立个Flag,希望自己以后能勤快一点更博吧。 参考文章: https://cloud.tencent.com/developer/article/1600265]]></content>
      <categories>
        <category>Serverless</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue3.0和Vue2.0响应式原理分析与实现]]></title>
    <url>%2F01%2F11%2Fvue3-0-principle%2F</url>
    <content type="text"><![CDATA[PS: 换个了电脑，墨迹了好久才有空重新搭环境，老早写了大半，一直拖着没发，emm… 终于发了。Vue3.0终于公布了一波源码，掀起了一股大风，我个菜鸡也跟风记录一波，顺便把Vue2.0的也一并码了。至于Vue1.0嘛，用着让人脑壳疼就偷懒不码了。 Vue3.0 响应式原理解析+手写实现简单使用12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script&gt; const App = &#123; template: `&#123;&#123;count&#125;&#125;`, data()&#123; return &#123; count: 1000 &#125; &#125; &#125; let container = document.getElementById('app') let proxy = Vue.createApp().mount(App, container) setTimeout(()=&gt;&#123; // 通过Proxy进行数据响应式变化 proxy.count = 2000 &#125;, 1000) &lt;/script&gt;&lt;/body&gt; 核心基于proxy,Vue.reactive()将数据设为响应式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// es6 弱引用映射表：WeakMap WeakSetconst toProxy = new WeakMap(); // 存放代理后的对象const toRaw = new WeakMap(); // 存放代理前的对象function trigger(target,type,key)&#123; console.log('触发视图更新') // 数据一变，effect就执行 let depsMap = targetsMap.get(traget) if(depsMap)&#123; let deps = depsMap.get(key) if(deps)&#123; deps.forEach(effect=&gt;&#123; effect() &#125;) &#125; &#125;&#125;function isObject(target)&#123; return typeof target === 'object' &amp;&amp; target !== null;&#125;//（栈：先进后出）let activeEffectsStacks = [] //栈型结果// &#123;// traget: &#123;// key: [fn,fn]// &#125;// &#125;let targetsMap = new WeakMap()// 如果target中的key变化了，就执行数组里的方法function track(traget,key)&#123; let effect = activeEffectsStacks[activeEffectsStacks.length-1] // 有对应关系才创建关联 if(effect)&#123; let depsMap = targetsMap.get(traget) if(!depsMap)&#123; targetsMap.set(target.depsMap = new Map()) &#125; let deps = depsMap.get(key) if(!deps)&#123; depsMap.set(key.deps = new Set()) &#125; if(!deps.has(effect))&#123; deps.add(effect) &#125; // 动态创建依赖关系 &#125; // 什么都不做&#125;// 响应式副作用// 当我们调用effect执行某个函数时，首先会执行一次这个函数。之后每次obj.name修改时，执行一次该函数function effect(fn)&#123; // 需要把fn这个函数变成响应式的函数 let effect = createReactiveEffect(fn) effect() // 默认要先执行一次&#125;function createReactiveEffect()&#123; // 创建响应式的effect let effect = function()&#123; // 运行：让fn执行，把effect存到栈中 return run(effect,fn) &#125; return effect&#125;// 运行fn并把effect存起来function run(effect, fn)&#123; try&#123; activeEffectsStacks.push(effect) fn() // vue2.0是利用了js的单线程特性 &#125;finally&#123; activeEffectsStacks.pop(effect) &#125;&#125;// target就是data中定义的所有变量， 即data()&#123;return &#123;&#125;&#125;中return的objectfunction reactive(target)&#123; // 不是对象的话就不用定义成响应式的了 if(!isObject(target))&#123; return target; &#125; // 如果代理hashmap中已经存在了，就把这个结果返回 if(toProxy.get(target))&#123; return toProxy.get(target) &#125; // 如果这个对象已经被代理了，就把它原封不动返回 if(toRaw.get(target))&#123; return target &#125; const handlers = &#123; // target为原数据 set(target, key, value, receiver)&#123; // (以下注释代码为无effect时的版本) // 改变数组的时候，会触发两次set,第一个是根据所以改对应的值，第二个是改数组的length，期望第二次不要触发视图更新 // if(target.hasOwnProperty(key))&#123; // trigger() // &#125; // 给某个变量设置某个值，返回操作成功与否的结果，普通的target[key]=value并不会有返回值,receiver可有可无 // return Reflect.set(target, key, value, receiver) // 如何识别时改属性还是新增属性 let hasKey = hasOwn(target,key) // 判断这个属性以前有没有 let oldValue = target[key] let result = Reflect.set(target, key, value, receiver) if(!hasKey)&#123; trigger(trigger,'add',key) &#125;else if(oldValue !== value)&#123; // 表示属性已经更改过了 trigger(target,'set',key) &#125;// 为了屏蔽无意义的修改 return result &#125;, get(target, key，receiver)&#123; // 等同于target[key] const result = Reflect.get(target, key，receiver) // 收集依赖(订阅)，把当前的key和这个effect对应起来，如果key变化了重新让数组的effect执行即可 track(target,key) // 递归：如果取的值是个对象，就继续代理 return isObject(result)?reactive(result):result &#125;, deleteProperty(target, key)&#123; return Reflect.deleteProperty(target, key) &#125; &#125; // 更改target的某个属性后，会触发handlers的方法 let observed = new Proxy(target, handlers)； // 避免重复代理，利用缓存直接返回 toProxy.set(target, observed) // reactive传入的是对象，原对象 ： 代理后的对象 toRaw.set(observed, target) // reactive传入的是代理对象，代理后的对象 ： 原对象 // 返回代理后的对象 return observed&#125;//调用let obj = &#123; name: 'abc', test: [1,2,3]&#125;let p = reactive(obj)// 测试重复代理// p = reactive(obj)// p = reactive(p) p.name = 'test'p.test.push(4)// 测试effectlet obj = reactive(&#123;name:'abc'&#125;)effect(()=&#123; console.log(obj.name)&#125;)obj.name = 'test' vue3.0响应式原理架构图 Vue2.0 响应式原理解析+手写实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 覆写数组的属性方法来达到数据响应let oldArrayPrototype = Array.oldArrayPrototypelet proto = Object.create(oldArrayPrototype) // 继承原有属性// 函数劫持，把函数进行重写，内部继续调用老的方法，此处只列举其中三个方法['push','shif','unshift'].forEach(method=&gt;&#123; proto[method] = function()&#123; // 在原方法的上新增 触发视图更新 的方法（切片编程） trigger() oldArrayPrototype[method].call(this,...arguments) &#125;&#125;)function observer(target)&#123; if(typeof target !== 'object' || target == null)&#123; return target &#125; // 拦截数组，给数组的方法进行重写 if(Array.isArray(target))&#123; Object.setPrototype(target,proto) // 写个循环，赋予给target // target.__proto__ = proto &#125; for(let key in target)&#123; defineReactive(target,key,target[key]) &#125;&#125;// 如果属性不存在，新增的属性还没执行过Object.defineProperty,所以不会刷新，所以才会有$set作为补充function defineReactive(target, key, value)&#123; // 递归,继续拦截这个对象 observer(value) // 通过Object.defineProperty重新定义属性，给属性增加get,set Object.defineProperty(target,key,&#123; // 进行依赖收集 get()&#123; return value &#125;, set(newValue)&#123; if(newValue !== value)&#123; trigger() value = newValue &#125; &#125; &#125;)&#125;function trigger()&#123; console.log('更新视图')&#125;// 调用let data = &#123;name:'test',age:&#123;n:100&#125;&#125;observer(data)data.age = &#123;n:200&#125;data.age.n = 300 vue2.0响应式原理架构图 总结 vue2.0的响应式是采用数据劫持结合发布者-订阅者模式，通过Object.defineProperty来getter和setter,在数据变化的时候发布消息给订阅者，触发相应的视图更新。 vue3.0的响应式是采用Proxy+Reflect反射的原理进行劫持getter和setter,数据变化触发代理对象的变化，发布消息给订阅者，然后触发相应的视图更新。 在2.0中，响应式处理是默认递归的，一旦数据层级太深内存消耗会高，所以数据要尽量扁平化；数组改变length是无效的，而且对象不存在的属性不能被拦截，如果需要动态添加响应式属性，要使用Vue.set。 在3.0中，响应式处理是经过判断后才递归，但是proxy的兼容性问题，IE11不兼容，这也意味着放弃兼容IE，3.0上实现就解决2.0中的以上问题。 在2.0中数据的响应式处理和视图没有完全解耦，则在3.0中通过effect来实现解决。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客缘起 Why Blog]]></title>
    <url>%2F12%2F30%2Fhello-world%20%2F</url>
    <content type="text"><![CDATA[自博客兴起之时就想着要写个自己的博客。看着人家名人发发博文，分享生活感悟，就想把自己写的那些诗文都发到博客上，也算是个念想、无奈自己是个极懒之人，也没什么耐心，估摸着自己开个博客也无心经营，遂放弃。直到大学毕业，自己入了程序猿这个坑，才把这个念想拾起。但苦于自己没什么水平，迟迟没有动手，直到现在。为什么现在想写博客了呢？写给自己。随着自己在程序猿这条路越走越远，遇到的一些问题和解决方案，总得记录下来，即使有些问题我已经心知肚明，但是也还是想把这些积累下来，帮助自己，说不定也能帮助到别人。同时，希望自己能写个中英文的博客，就当练练英文吧。至于，能不能坚持下来呢，随心吧。 Since the rise of the blog, I wanna build a blog of mine. Why? Cause I found that celebrities write their blog to share life and sentiment, which is funny. So that I wanna post my poems and articles on the blog. But what a pretty lazy and no patience people of me, that I thought I cannot keep manamge the blog as time gone. So, abandon. Until graduated, pick up this mind when I jump down to the developer career. Cause I known I have nothing deserve to write on the blog, haven’t do it yet. But why blog now? For myself. As my job of developer, so many problems and confuse worth to mark it, even some of them had keep in my mind. I hope these can help me, maybe some one else. At the same time, I hope that I can write a blog with Chinese and English for my English practice. As for, whether it can hold on just depends on my mood. 1Console.log("Welcome to Avril's Blog.");]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于JavaScript的简单DevOps]]></title>
    <url>%2F10%2F11%2Fsimple-release%2F</url>
    <content type="text"><![CDATA[平时的工作中，项目的持续集成和部署会有运维负责，随着DevOps的提倡，开发学习部署是大势所趋。得益于工作中小组的发展，所负责的项目都是通过公司运维搭建的gitlab和Rancher集成实现CI/CD，加快了上线速度。但是作为个人实践与学习，还是从基础开始吧，在此做个笔记。相关代码：https://github.com/LinLzis/simple-devops 1.持续集成和布署 技术栈 前台Vue.js,后台Node.js 服务器 前台Nginx,后台Node.js 如图：开发人员提交代码到Git服务器后，触发Webhook通知CI Server到Git仓库pull最新的代码进行自动化构建、测试，然后CD Server自动让不同环境的Docker到构建好的镜像服务器中拉取对应的镜像进行部署。 2.编写后端服务2.1 package.json/usr/projects/vue-back/package.json12345678&#123; "name": "vue-back", "version": "0.0.0", "private": true, "scripts": &#123;+ "start": "node ./server.js " &#125;&#125; 2.2 server.js/usr/projects/vue-back/server.js1234567891011121314151617let http = require('http');let users = [ &#123;id:100,name:'user1'&#125;, &#123;id:101,name:'user2'&#125;, &#123;id:1002,name:'user3'&#125;]let server = http.createServer(function(req,res)&#123; res.setHeader('Access-Control-Allow-Origin','*'); if(req.url === '/api/users')&#123; res.json(users); &#125;else&#123; res.send('API Not Found'); &#125;&#125;);server.listen(3000,()=&gt;&#123; console.log('Server Run Port: 3000')&#125;); 2.3 .gitignore/usr/projects/vue-back/.gitignore123node_moduleslibpackage-lock.json 3.前端项目3.1 安装脚手架生成项目1234cnpm i @vue/cli -gvue create vue-frontcd vue-frontcnpm i axios -S 3.2 App.vue/usr/projects/vue-front/src/App.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;ul&gt; &lt;li v-for="(user) in users" :key="user.id"&gt; &#123;&#123;user.id&#125;&#125;:&#123;&#123;user.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios';export default &#123; name: 'app', data()&#123; return &#123; users:[] &#125; &#125;, mounted()&#123; axios.get('http://localhost:3000/api/users').then(response=&gt;&#123; this.users = response.data; &#125;); &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 4. CI/CD服务器 webhooks文档 pushevent 4.1 生成项目1234mkdir vue-webhookcd vue-webhookcnpm init -ycnpm i nodemailer -S 4.2 webhook.js/usr/projects/vue-webhook/webhook.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let http = require('http');let crypto = require('crypto');let &#123;spawn&#125; = require('child_process');let SECRET= '123456';let sendMail = require('./sendMail');function sign(body)&#123; return `sha1=`+crypto.createHmac('sha1',SECRET).update(body).digest('hex');&#125;let server = http.createServer(function(req,res)&#123; console.log(req.method,req.url); if(req.method == 'POST' &amp;&amp; req.url == '/webhook')&#123; let buffers = []; req.on('data',function(buffer)&#123; buffers.push(buffer); &#125;); req.on('end',function(buffer)&#123; let body = Buffer.concat(buffers); let event = req.headers['x-github-event']; //event=push //github请求来的时候，要传递请求体body,另外还会传一个signature过来，需要验证签名 let signature = req.headers['x-hub-signature']; if(signature !== sign(body))&#123; return res.send('Not Allowed'); &#125; res.setHeader('Content-Type','application/json'); res.send(JSON.stringify(&#123;ok:true&#125;)); if(event == 'push')&#123;//开始布署 let payload = JSON.parse(body); let child = spawn('sh',[`./$&#123;payload.repository.name&#125;.sh`]); let buffers = []; child.stdout.on('data',function(buffer)&#123; buffers.push(buffer); &#125;); child.stdout.on('end',function(buffer)&#123; let logs = Buffer.concat(buffers).toString(); sendMail(` &lt;h1&gt;部署日期: $&#123;new Date()&#125;&lt;/h1&gt; &lt;h2&gt;部署人: $&#123;payload.pusher.name&#125;&lt;/h2&gt; &lt;h2&gt;部署邮箱: $&#123;payload.pusher.email&#125;&lt;/h2&gt; &lt;h2&gt;提交信息: $&#123;payload.head_commit&amp;&amp;payload.head_commit['message']&#125;&lt;/h2&gt; &lt;h2&gt;布署日志: $&#123;logs.replace("\r\n",'&lt;br/&gt;')&#125;&lt;/h2&gt; `); &#125;); &#125; &#125;); &#125;else&#123; res.send('Not Found'); &#125;&#125;);server.listen(4000,()=&gt;&#123; console.log('Webhook Run Port：4000')&#125;); 4.3 sendMail.js nodemailer /usr/projects/vue-webhook/sendMail.js12345678910111213141516171819202122232425262728293031const nodemailer = require('nodemailer');let transporter = nodemailer.createTransport(&#123; // host: 'smtp.ethereal.email', service: 'qq', // 使用了内置传输发送邮件 查看支持列表：https://nodemailer.com/smtp/well-known/ port: 465, // SMTP 端口 secureConnection: true, // 使用了 SSL auth: &#123; user: '283023603@qq.com', // smtp授权码 pass: 'zpdfteyhjfbpcaff', &#125;&#125;);function sendMail(message)&#123; let mailOptions = &#123; from: '"Avril Li" &lt;283023603@qq.com&gt;', // 发送地址 to: '283023603@qq.com', // 接收者 subject: '部署通知', // 主题 html:message // 内容主体 &#125;; // send mail with defined transport object transporter.sendMail(mailOptions, (error, info) =&gt; &#123; if (error) &#123; return console.log(error); &#125; console.log('Message sent: %s', info.messageId); &#125;);&#125;module.exports = sendMail;` 4.4 package.json/usr/projects/vue-webhook/package.json 12345678910111213141516&#123; "name": "vue-webhooks", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123;+ "start": "pm2 start ./webhook.js --watch --name='vue-webhook'",+ "stop": "pm2 stop vue-webhook" &#125;, "keywords": [], "author": "", "license": "ISC", "dependencies": &#123; "nodemailer": "^6.3.0" &#125;&#125; 5. 配置服务器5.1 更新系统1234#升级所有包同时也升级软件和系统内核yum update #只升级所有包，不升级软件和系统内核yum upgrade 5.2 docker是什么? Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样 5.3 安装docker12345yum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum install -y docker-ce docker-ce-cli containerd.io 5.4 阿里云加速123456789mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://fwvjnv59.mirror.aliyuncs.com"]&#125;EOF# 重载所有修改过的配置文件systemctl daemon-reloadsystemctl restart docker 5.5 生成公钥并添加github https://github.com/settings/keys 12ssh-keygen -t rsa -C "&lt;your.name&gt;@qq.comcat /root/.ssh/id_rsa.pub 5.6 安装git1234yum install git -ygit clone git@github.com:&lt;your.git.name&gt;/vue-front.gitgit clone git@github.com:&lt;your.git.name&gt;/vue-back.gitgit clone git@github.com:&lt;your.git.name&gt;/vue-webhook.git ~.gitconfig1234[alias] a = add -A c = commit -m"msg" p = push origin master 5.7 安装node和npm NVM Node.js多版本管理 NRM NPM源的切换1234567wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bashsource /root/.bashrc# 安装最新的Node稳定版本nvm install stablenpm i nrm -gnrm use taobaonpm i pm2 -g 5.8 安装启动服务5.8.1 vue-back1234cd /usr/projects/vue-backnpm i npm run startcurl http://localhost:3000 5.8.2 vue-front1234cd /usr/projects/vue-frontnpm i npm run servecurl http://localhost:8080 5.8.3 vue-webhook12345cd /usr/projects/vue-webhooknpm inpm run start curl http://localhost:4000curl http://47.104.15.123:4000/webhook 6. 后台布署6.1 vue-back.sh/usr/projects/vue-webhook/vue-back.sh123456789101112131415#!/bin/bashWORK_PATH='/usr/projects/vue-back'cd $WORK_PATHecho "清理代码"git reset --hard origin/mastergit clean -fecho "拉取最新代码"git pull origin masterecho "开始构建镜像"docker build -t vue-back .echo "删除旧容器"docker stop vue-back-containerdocker rm vue-back-containerecho "启动新容器"docker container run -p 3000:3000 -d --name vue-back-container vue-back 6.2 Dockerfile/usr/projects/vue-back/Dockerfile12345678FROM nodeLABEL name=&quot;vue-back&quot;LABEL version=&quot;1.0&quot;COPY . /appWORKDIR /appRUN npm installEXPOSE 3000CMD npm start 6.3 .dockerignore/usr/projects/vue-back/.dockerignore12345.gitnode_modulespackage-lock.jsonDockerfile.dockerignore 7. 前台布署7.1 vue-front.sh/usr/projects/vue-webhook/vue-front.sh1234567891011121314151617#!/bin/bashWORK_PATH='/usr/projects/vue-front'cd $WORK_PATHecho "清理代码"git reset --hard origin/mastergit clean -fecho "拉取最新代码"git pull origin masterecho "打包最新代码"npm run buildecho "开始构建镜像"docker build -t vue-front .echo "删除旧容器"docker stop vue-front-containerdocker rm vue-front-containerecho "启动新容器"docker container run -p 80:80 -d --name vue-front-container vue-front 7.2 Dockerfile/usr/projects/vue-front/Dockerfile123456FROM nginxLABEL name=&quot;vue-front&quot;LABEL version=&quot;1.0&quot;COPY ./dist/ /usr/share/nginx/html/COPY ./vue-front.conf /etc/nginx/conf.d/EXPOSE 80 7.3 vue-front.conf/usr/projects/vue-front/vue-front.conf123456789101112server &#123; listen 80; server_name 47.104.15.123; location / &#123; root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; location /api &#123; proxy_pass http://47.104.15.123:3000; &#125;&#125; 7.4 .dockerignore/usr/projects/vue-front/.dockerignore12345.gitnode_modulespackage-lock.jsonDockerfile.dockerignore 8. 集成部署 Compose 通过一个配置文件来管理多个Docker容器 在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动、停止和重启应用和应用中的服务以及所有依赖服务的容器 最后，运行docker-compose up，Compose 将启动并运行整个应用程序 配置文件组成 8.1 docker-compose.yml/usr/projects/docker-compose.yml1234567891011121314version: '2'services: api: build: context: ./vue-back dockerfile: Dockerfile ports: - "3000:3000" web: build: context: ./vue-front dockerfile: Dockerfile ports: - "80:80" 8.2 安装docker-compose12curl -L https://github.com/docker/compose/releases/download/1.23.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 8.3 启动服务12docker-compose updocker-compuse up -d 8.4 cicd.sh/usr/projects/vue-webhook/cicd.sh12345678910111213141516171819202122232425#!/bin/bashWORK_PATH='/usr/projects/vue-back'cd $WORK_PATHecho "清理后台代码"git reset --hard origin/mastergit clean -fecho "拉取后台最新代码"git pull origin masterWORK_PATH='/usr/projects/vue-front'cd $WORK_PATHecho "清理前台代码"git reset --hard origin/mastergit clean -fecho "拉取前台最新代码"git pull origin masterecho "打包前台最新代码"npm run buildcd /usr/projectsecho "删除老资源"docker-compose downecho "重启所有服务"docker-compose up -d]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Vue DevOps Release</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mini Vuex]]></title>
    <url>%2F09%2F19%2Fmini-vuex%2F</url>
    <content type="text"><![CDATA[接着上篇，把手写简单版vuex也总结一下做个笔记。手写vuex很多东西是跟vue-router相似的，相同的东西不再赘述。 惯例，先上个Vuex的图： 然后上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Vueclass Store &#123; constructor(options) &#123; // state要实时更新，就要变成响应式数据 // 通过new Vue产生新的实例，对应产生getter和setter, 若数据更新则视图刷新 // 和Vue.util.defineReactive效果一样，只是原码上是以这种方式 // PS: 这句是核心呐 this._vm = new Vue(&#123; data: &#123; state: options.state &#125; &#125;) this.state = this._vm.state this.mutations = options.mutations this.actions = options.actions &#125; // 执行commit的事件后调到对应方法并执行 commit = (eventName) =&gt; &#123; this.mutations[eventName](this.state) &#125; // 执行actions里的对应方法，this是当前Store可解构出commit dispatch = (eventName) =&gt; &#123; this.actions[eventName](this) &#125;&#125;// 提供install方法const install = (_Vue) =&gt; &#123; Vue = _Vue Vue.mixin(&#123; beforeCreate() &#123; // 组件加载是深度优先 if (this.$options &amp;&amp; this.$options.store) &#123; this.$store = this.$options.store &#125; else &#123; this.$store = this.$parent &amp;&amp; this.$parent.$store &#125; &#125; &#125;)&#125;// 导出类，对应new Vue.Store()和Vue.use()export default &#123; Store, install&#125; 然后，还有个优化版的，参考于姜老师的资料，不作阐述。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869let Vueconst forEach = (obj, callback) =&gt; Object.keys(obj).forEach(key =&gt; callback(key, obj[key]))class Store &#123; constructor(options) &#123; this.getters = &#123;&#125; this._vm = new Vue(&#123; data: &#123; state: options.state &#125; &#125;) const &#123; getters &#125; = options if (getters) &#123; Object.keys(getters).forEach((key) =&gt; &#123; Object.defineProperty(this.getters, key, &#123; // 定义getters get: () =&gt; getters[key](this.state) &#125;) &#125;) &#125; this.mutations = &#123;&#125; const &#123; mutations &#125; = options if (mutations) &#123; forEach(mutations, (key, value) =&gt; &#123; this.mutations[key] = () =&gt; &#123; value.call(this, this.state) &#125; &#125;) &#125; const &#123; actions &#125; = options if (actions) &#123; forEach(actions, (key, value) =&gt; &#123; this.actions[key] = () =&gt; &#123; value.call(this, this) &#125; &#125;) &#125; &#125; get state() &#123; return this._vm.state &#125; commit = (eventName) =&gt; &#123; this.mutations(this, eventName) &#125;; dispatch = (eventName) =&gt; &#123; this.actions(this, eventName) &#125;;&#125;// 提供install方法const install = (_Vue) =&gt; &#123; Vue = _Vue Vue.mixin(&#123; beforeCreate() &#123; // 组件加载是深度优先 if (this.$options &amp;&amp; this.$options.store) &#123; this.$store = this.$options.store &#125; else &#123; this.$store = this.$parent &amp;&amp; this.$parent.$store &#125; &#125; &#125;)&#125;export default &#123; Store, install&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mini vue-router]]></title>
    <url>%2F09%2F18%2Fmini-vue-router%2F</url>
    <content type="text"><![CDATA[前段时间听了点课，结合自己的理解把关于手写简单的vue-router做个笔记吧。不废话了，上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 用于获取当前Vuelet Vue// 1. 声明VueRouter类/*（PS：函数声明会提升，类声明不会。要先声明你的类，然后才能访问它，否则会抛出ReferenceError）*/class Router &#123; constructor(&#123; routes &#125;) &#123; // 7. 映射路由表 this.routeMap = routes.reduce((memo, route) =&gt; &#123; // 把path作为key，组件为value memo[route.path] = route.component return memo &#125;, &#123;&#125;) // 9. 把当前路径属性定义成响应式数据，视图才刷新 // 或Vue.util.defineReactive(this.route = &#123;&#125;, 'path', '/') // 也可以用Vue.$set但是内部源码里用的是这个 Vue.util.defineReactive(this, 'route', &#123; path: '/' &#125;) // 10. 页面加载的时候跳转（这里只处理hash的跳转） window.addEventListener('load', () =&gt; &#123; // 页面加载的时候，默认跳转到首页 location.hash ? '' : location.hash = '/' &#125;) // hash更新 window.addEventListener('hashchange', () =&gt; &#123; // 跳转到对应路由，把#去掉 this.route.path = location.hash.slice(1) &#125;) &#125;&#125;// 2. 提供一个install方法来全局注册该组件（对应Vue.use()）// 可以扩展属性/组件/指令Router.install = function(_Vue) &#123; // _Vue是当前Vue的构造函数 Vue = _Vue // 3. 在beforeCreate的时候把router的定义mixin到所有的Vue实例 /* （PS: 让每个组件都能共享router实例，可以Vue.prototype.router， 但是这样就每个new Vue都会有这个属性， 实际上我们只需要main.js/App.vue开始的才拥有，所以要给每个组件单独添加router） */ Vue.mixin(&#123; beforeCreate() &#123; // 4. 先找根组件，再一层层往下 // 确保只有配置了router的Vue实例根节点及其子孙节点才有对应的router // this.$options即new Vue(&#123;...router&#125;), 只有根组件才会传这个对象 if (this.$options &amp;&amp; this.$options.router) &#123; // 保存当前的router this._router = this.$options.router &#125; else &#123; // 让所有的子组件都有_router属性指向当前的router(即传进来的new Router实例) // 若Router中有属性p，则可获取到this._router.p的值 this._router = this.$parent &amp;&amp; this.$parent._router &#125; // 5. 给每个组件添加$route和$routers属性，即_router Object.defineProperty(this, '$route', &#123; value: &#123; route: this._router.route &#125; &#125;) Object.defineProperty(this, '$router', &#123; value: &#123; route: this._router.route &#125; &#125;) &#125; &#125;) // 6. 定义路由两大组件&lt;router-link&gt;和&lt;router-view&gt; /* (PS：如果放进mixin里面，会重复定义，但是vue会判断，所以也不会影响，但最好是各司其职) */ Vue.component('router-link', &#123; props: &#123; to: &#123; type: String, default: '/' &#125; &#125;, render(h) &#123; // 获取router-link,实际就是个a标签 // PS：此处目前只处理了hash类型的路由分配所以是# // this.$slots.default 即默认的标签的内容 return &lt;a href=&#123;`#$&#123;this.to&#125;`&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt; &#125; &#125;) // 8. 显示对应的组件 Vue.component('router-view', &#123; render(h) &#123; // 根据路由表里的组件路径，渲染组件 return h(this._router.routeMap[this.$route.route.path]) &#125; &#125;)&#125;// 把这个组件类导出，在router.js中引用export default Router Router层级关系图：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件间的通信方式]]></title>
    <url>%2F09%2F16%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[PS：加班使我麻木，终于想起来要更一下博客了。Vue组件间的通信方式是老生常谈了，所以必不可免地简单地归纳一下。主要分为八个方向：Props传递数据，$emit，$parent+$children，$attrs+$listeners，Provide+Inject，Ref，EventBus，Vuex 1. Props传递数据（父传子）父组件调用子组件123456789101112131415161718&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123;msg&#125;&#125; &lt;Son :msg="msg"&gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from "./Son"export default &#123; components: &#123; Son &#125;, data() &#123; return &#123; msg: 'From Father' &#125;; &#125;&#125;;&lt;/script&gt; 子组件获取数据123456789101112131415&lt;template&gt; &lt;div&gt;来自父组件的消息：&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Son', props: &#123; msg: &#123; type: String, required: true &#125; &#125;&#125;&lt;/script&gt; 2. $emit传递数据子组件触发父组件方法,通过回调的方式将修改的内容传递给父组件1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123; price &#125;&#125; &lt;Son :price="price" @input="change"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from './Son'export default &#123; components: &#123; Son &#125;, data() &#123; return &#123; price: 100 &#125; &#125;, methods: &#123; change(price) &#123; this.price = price &#125; &#125;&#125;&lt;/script&gt; 子组件触发绑定自己身上的方法1234567891011121314151617&lt;template&gt; &lt;div&gt; 子组件: &#123;&#123; price &#125;&#125; &lt;button @click="$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; price: &#123; type: Number, required: true &#125; &#125;&#125;&lt;/script&gt; .sync123&lt;Son :price.sync="price"&gt;&lt;/Son&gt;&lt;!-- 触发的事件名 update:(绑定.sync属性的名字) --&gt;&lt;button @click="$emit('update:price',200)"&gt;更改&lt;/button&gt; v-model123456789101112131415161718192021&lt;!-- 父组件调用子组件 --&gt;&lt;Son v-model="price"&gt;&lt;/Son&gt;&lt;!-- 子组件触发更改 --&gt;&lt;template&gt; &lt;div&gt; 子组件: &#123;&#123; value &#125;&#125; // 触发的事件只能是input &lt;button @click="$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; // 接收到的属性名只能叫value type: Number, required: true &#125; &#125;&#125;&lt;/script&gt; 3. $parent、$children父传子，子传孙。123456789101112131415161718192021&lt;!-- 子组件调用孙子组件 --&gt;&lt;Grandson :value="value"&gt;&lt;/Grandson&gt;&lt;!-- 孙子组件 --&gt;&lt;template&gt; &lt;div&gt; 孙子:&#123;&#123; value &#125;&#125; &lt;!-- 调用父组件的input事件 --&gt; &lt;button @click="$parent.$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; type: Number, required: true &#125; &#125;&#125;&lt;/script&gt; 如果层级很深那么就会出现$parent.$parent…..可以封装一个$dispatch方法向上进行派发 $dispatch1234567Vue.prototype.$dispatch = function $dispatch(eventName, data) &#123; let parent = this.$parent while (parent) &#123; parent.$emit(eventName, data) parent = parent.$parent &#125;&#125; 同理，可以向上派发 $broadcast1234567891011Vue.prototype.$broadcast = function $broadcast(eventName, data) &#123; const broadcast = function() &#123; this.$children.forEach((child) =&gt; &#123; child.$emit(eventName, data) if (child.$children) &#123; $broadcast.call(child, eventName, data) &#125; &#125;) &#125; broadcast.call(this, eventName, data)&#125; 4. $attrs、$listeners 批量向下传递属性 $attrs12345678910111213&lt;!-- 父组件调用子组件 --&gt;&lt;Son name="测试" age="10"&gt;&lt;/Son&gt;&lt;!-- 可以在son组件中使用$attrs属性,可以将属性继续向下传递 --&gt;&lt;div&gt; 儿子: &#123;&#123;$attrs.name&#125;&#125; &lt;Grandson v-bind="$attrs"&gt;&lt;/Grandson&gt;&lt;/div&gt;&lt;!-- 孙子组件 --&gt;&lt;template&gt; &lt;div&gt;孙子:&#123;&#123; $attrs &#125;&#125;&lt;/div&gt;&lt;/template&gt; 批量向上传递属性 $listeners12345678&lt;!-- 父组件调用子组件 --&gt;&lt;Son name="测试" age="10" @click="()=&gt;&#123;this.price = 500&#125;"&gt;&lt;/Son&gt;&lt;!-- 子组件：可以在son组件中使用listeners属性,可以将方法继续向下传递 --&gt;&lt;Grandson v-bind="$attrs" v-on="$listeners"&gt;&lt;/Grandson&gt;&lt;!-- 孙子组件 --&gt;&lt;button @click="$listeners.click()"&gt;更改&lt;/button&gt; 5. Provide、 Inject Provie: 在父级中注入数据 123provide() &#123; return &#123; parentMsg: "父亲" &#125;&#125; Inject: 在任意子组件中可以注入父级数据 12// 会将数据挂载在当前实例上inject: ["parentMsg"] 6. Ref获取组件实例Ref我常用于调用子组件的属性和方法，简洁明了。1234567891011&lt;!-- 父级组件调用子级组件 --&gt;&lt;Grandson v-bind="$attrs" v-on="$listeners" ref="grand"&gt;&lt;/Grandson&gt;&lt;script&gt;export default &#123; mounted() &#123; // 获取组件定义的属性 console.log(this.$refs.grand.name) &#125;&#125;&lt;/script&gt; 7. EventBus其实就是利用一个Vue实例传递数据，实现跨组件通知（简单的项目可以使用此方式）1Vue.prototype.$bus = new Vue() Son组件和Grandson相互通信12345mounted() &#123; this.$bus.$on("my", data =&gt; &#123; console.log(data); &#125;)&#125; 12345mounted() &#123; this.$nextTick(() =&gt; &#123; this.$bus.$emit("my", "我是Grandson"); &#125;)&#125; 8. Vuex状态管理数据通信交互较多的项目还是用Vuex统一管理吧，具体使用参考Vuex官方文档，在这就放个图。 最后，总结一波： 父传子： Props, $broadcast, $attrs, $listeners, Provide+Inject 子传父： $emit, $dispatch 父子双向： .sync, v-model 兄弟互传：EventBus, Vuex （PS：也可以都dispatch到最上层父级再派发，但是不建议）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户体验那些事 About UE]]></title>
    <url>%2F11%2F23%2F%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[PS：频繁地换电脑一度中断了我写博客的心情，嗯，感慨一下，终于。关于用户体验其实有太多的内容可以研究，鉴于之前在工作小组内做过分享，浅显地总结归纳为三个方面：布局优化，内容优化，配色优化。在这里做个简单地总结。 Such conent to study about UE. as the previous sharing in my work team, can be summarized into 3 aspects: layout optimization, content optimization，color matching optimization. Just make a brief summary here. 布局优化 Layout Optimization布局优化旨在页面组件结构的优化，让页面更简洁美观并且舒适。大致可以归纳成三点:专注主题，保持简洁，适当的突出与柔化Layout optimization is designed to optimize the structure of the page components, making the page more concise and comfortable. It can be roughly summarized into three points: Keep Focus，Keep Concise，Appropriate highlighting and softening *Try Merging Similar Functions instead of fragmenting the UIExample: Try A One Column Layout instead of multi-columnsExample: Try Recommending instead of showing equal choicesExample: Try Friendly Comparisons instead of confusionExample: Try Fewer Borders instead of wasting attention Try Softer Prompts instead of modal windows Try line of sight instead of jumping 内容优化 Contetnt Optimization内容优化旨在用户交互的内容及流程优化。大致可以归纳成四点：易学性，高效性，满足性，错误处理Contetnt optimization is aimed at the process and content optimization of user interaction.It can be roughly summarized into three points: Learnability，Efficiency，Satisfaction，Error Handle Try Social Proof instead of talking about yourselfExample: Try Fewer Form Fields instead of asking for too manyExample: Try Undos instead of prompting for confirmationExample: Try Set Collections instead of independent itemsExample: Try Telling Who It’s For instead of targeting everyone Try Exposing Options instead of hiding them Try Keeping Focus instead of drowning with links Try Selling Benefits instead of features Try Opt-Out instead of opt-in Try smart defaults instead of asking to do extra work Try Recognition instead of recallExample: Try Inline Validation instead of delaying errorsExample: Try to show error more friendlyExample: 配色优化 Color Matching Optimization配色优化旨在页面整体视觉效果的优化。大致可以归纳为3点：舒适，和谐，可区分Color optimization is optimized for the overall visual effect of the page. It can be roughly summarized into three points: comfortable， harmonious, diacritical 根据网页主题风格配色 Color matching according to the theme of the webpage 黄色：乐观、年轻，常被使用在获取window shopper的注意力 红色：充满活力、心跳加速、创造急迫性，常出现在清仓大拍卖 蓝色：建立信任感和安全感，常出现在银行和企业 绿色：跟健康有关，对眼睛来说最舒服的颜色，通常会使用在实体店家，可传递放松的感觉 橘色：积极、创造行动呼吁，以带动订阅、购买或销售 粉红色：浪漫和女性主义，通常会女性的和年轻女性的产品市场出现 黑色：强而有力，通常出现在奢华的商品上 紫色：放松和冷静，常被用在常美妆和抗老化的产品 同一版面勿使用超过3种纯色，宁缺毋滥 Do not use more than 3 solid colors for the same layout 超链接的样式与状态的色彩搭配 The style of hyperlink status(Status: normal, hover, focus, visited) -&gt; -&gt; -&gt; 浅色背景搭配深色字体较易阅读 A light background with a dark font is easier to read 所提及的内容经本人筛选，适用于较为严肃的商业网站。 参考： goodui]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UX</tag>
        <tag>用户体验</tag>
      </tags>
  </entry>
</search>
